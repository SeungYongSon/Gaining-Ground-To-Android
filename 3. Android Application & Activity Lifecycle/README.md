# 3. 안드로이드 애플리케이션과 액티비티 생명주기

시간이 지날수록 모바일 장치의 메모리나 컴퓨팅 능력이 향상되고 있지만 컴퓨터 시스템에 비해 여전히 제한된 리소스를 고려해야 한다. 특히, 메모리가 그렇다. 안드로이드 시스템에도 그런 제한된 리소스를 효율적으로 관리해야 한다. 운영체제와 애플리케이션 모두에서 그렇다. 그러면서 항상 사용자에게 응답할 수 있어야 한다. 따라서 안드로이드 시스템에서는 애플리케이션과 애플리케이션을 구성하는 각 컴포넌트 모두의 생명주기와 상태를 전적으로 통제한다. 그러므로 안드로이드 애플리케이션과 액티비티 생명주기 관리 모델을 이해하는 것이 중요하다. 또한, 애플리케이션이 실행하는 동안 상태 변경에 대처할 수 있는 방법도 알야아 한다. 

이 장에서는 안드로이드 런타임 시스템에서 실행되는 애플리케이션과 액티비티의 생명주기(lifecycle)에 대해 알아보자.


## 3-1. 안드로이드 애플리케이션과 리소스 관리

안드로이드 5.0 롤리팝 이전에는 안드로이드 애플리케이션이 달빅 가상 머신(Dalvik Virtual Machine)의 인스턴스에 실행되고, 각 가상 머신은 운영체제(리눅스)의 별개 프로세스로 실행되었다. 그러나 그 이후 안드로이드 버젼 부터는 가상 머신이 없어지고 안드로이드 런타임(ART) 시스템의 통제하에 리눅스 프로세스로 실행된다. 만약 장치의 리소스(특히 메모리)가 한계에 도달하면 안드로이드 시스템에서 메모리를 해제하기 위해 프로세스들을 중단시키는 조치를 취한다.

메모리 헤제를 위해 어떤 프로세스를 중단시킬지 결정할 때 시스템에서 현재 실행 중인 모든 프로세스들의 우선순위(priority)와 상태(state) 모두 고려한다. 이때, 그런 요소들을 결합하여 구글에서 이야기하는 중요도 서열(importance hierarchy)이라는 것을 생성한다. 그다음에 가장 낮은 순위의 프로세들부터 중단을 시작해서 시스템이 기능을 수행하는 데 충분한 리소스가 해제될 때까지 작업을 반복한다.

## 3-2. 안드로이드 프로세스 상태

애플리케이션은 프로세스로 실행되고 컴포넌트로 구성된다. 안드로이드 시스템에서 프로세스의 현재 상태는 애플리케이션 내부에서 실행중인 컴포넌트(액티비티나 서비스 등의) 우선순위에 의해 결정된다.

![안드로이드 프로세스 상태](https://github.com/SeungYongSon/Gaining-Ground-To-Android/blob/master/3.%20Android%20Application%20%26%20Activity%20Lifecycle/image/ProcessState.png "안드로이드 프로세스 상태")

위에 그림 처럼 어떤 시점에서든 프로세스는 다음 다섯 가지 중 하나의 상태가 될 수 있다.

### 3-2-1. 포그라운드 프로세스

이 프로세스는 가장 높은 수준의 우선순위가 지정된다. 프로세스가 포그라운드(foreground)상태로 되려면 밑의 조건을 하나 이상 충족해야 한다.

* 사용자와 현재 상호작용 중인 액티비티를 호스팅(포함해서 실행)한다.

* 사용자와 현재 상호작용 중인 액티비티에 연결된 서비스를 호스팅한다.

* 중단되면 사용자에게 해를 끼칠 수 있다는 것을 startForeground() 메서드를 호출하여 알려준 서비스를 호스팅한다.

* 자신의 onCreate(), onResume(), onStart() 콜백 메서드 중 하나를 실행하는 서비스를 호스팅한다.

* onReceive() 메서드로 현재 실행 중인 브로드캐스트 수신자를 호스팅한다.

### 3-2-2. 가시적 프로세스

화면적으로 볼 수 있는 있지만 사용자와 상호작용은 하지 않는 액티비티를 포함하는 프로세스는 가시적 프로세스(visible process)로 분류된다. 프로세스의 액티비티를 사용자가 화면에서 볼 수 있지만, 이 액티비티의 화면 일부를 다른 액티비티(예를 들어, Dialog)가 포그라운드로 실행하면서 가리는 경우다. 가시적이거나 포그라운드로 실행되는 액티비티와 결부된 서비스를 호스팅하는 프로세스도 가시적 상태가 될 수 있다.

### 3-2-3. 서비스 프로세스

이미 시작되어 현재 실행 중인 서비스(service)를 포함하는 프로세스다.

### 3-2-4. 백그라운드 프로세스

사용자가 화면으로 현재 볼 수 없는 하나 이상의 액티비티를 포함하는 프로세스다. 더 높은 우선순위의 프로세스에서 추가 메모리가 필요한 경우, 이 부류의 프로세스는 안드로이드 런타임에 의해 중단될 가능성이 크다. 안드로이드는 백그라운드 프로세스(background process)의 내역을 동적으로 유지 관리하면서 실행 순서에 따라 프로세스를 중단시킨다. 즉, 포그라운드에서 실행한 프로세스 중 가장 오래된 프로세스가 먼저 종료된다.

### 3-2-5. 비어 있는 프로세스

비어 있는 프로세스(empty process)는 실행되는 애플리케이셔을 포함하지 않으며, 새로 런칭되는 애플리케이션을 호스팅하기 위해 메모리에 남아 있다. 문을 연 채로 엔진을 켜 놓고 승객의 탑승을 기다리는 버스와 유사하다. 이런 프로세스는 최저 우선순위를 가지며, 리소스 해제 시에 제일 먼저 중단된다.

# 3-3. 액티비티 생명주기

안드로이드 프로세스의 상태는 자신이 호스팅하는 애플리케이션을 구성하는 액티비티와 컴포넌트의 상태에 의해 결정된다. 그러므로 애플리케이션이 실행되는 동안 액티비티도 서로 다른 상태로 전환된다는 것을 이해하는 것이 중요하다. 액티비티의 현재 상태는 액티비티 스택(activity stack) 안에서의 위치에 따라 결정된다.

# 3-4. 액티비티 스택

안드로이드 런타임 시스템에서는 장치에서 실행 중인 각 애플리케이션에 대해 액티비티 스택을 유지 관리한다. 애플리케이션이 런칭되면 그 애플리케이션의 첫 번째 시작 액티비티가 스택에 놓인다. 그리고 두 번째 액티비티가 시작되면 이전 액티비티는 밑으로 들어가고(push) 그 액티비티가 스택의 맨 위에 위치하게 된다. 스택의 맨 위에 있는 액티비티를 활성화된(또는 실행중인) 액티비티라 한다. 활성화된 액티비티가 종료되면 그 액티비티는 런타임에 의해 스택에서 빠지고(pop) 그 바로 밑에 있던 액티비티가 위로 올라오면서 현재 활성화된 액티비티가 된다.

액티비티가 종료되는 경우를 예를 들면, 스택의 맨 위에 잇는 액티비티가 자신의 할 일을 끝났을 경우나 이전 액티비티로 돌아가기 위해 사용자가 장치 화면의 Back 버튼을 눌렀을 경우다(이 경우는 현재 액티비티가 런타임 시스템에 의해 스택에서 빠지고 소멸된다). 

![액티비티 스택](https://github.com/SeungYongSon/Gaining-Ground-To-Android/blob/master/3.%20Android%20Application%20%26%20Activity%20Lifecycle/image/ActivityStack.png "액티비티 스택")

위 의 그림이 안드로이드 액티비티 스택을 잘 보여주고 있다.

새로운 액티비티가 시작되면 스택의 맨 위로 들어간다. 그리고 새로운 액티비티를 포함해서 현재 실행중인 액티비티는 스택의 맨 위에 위치한다. 그러나 새로운 액티비티가 시작되면 현재의 액티비티는 그 밑으로 들어간다. 또한, 현재의 액티비티가 종료되거나 또는 사용자가 Back 버튼을 눌러 이전 액티비티로 돌아갔을 때는 현재의 액티비티가 스택에서 꺼내어진다. 만일 시스템의 리소스(메모리 등)가 부족하게 될 경우는 스택의 제일 밑에 있는 액티비티부터 제거된다.

액티비티 스택은 후입선출(LIFO. Last-In-First-Out) 스택이다. 즉, 마지막에 스택으로 들어간 항목이 제일 먼저 꺼내어진다.

# 3-5. 액티비티 상태

애플리케이션에서 실행되는 동안 액티비티는 아래와 같이 서로 다른 상태를 거친다.

- **실행(Active/Running)** - 액티비티가 액티비티 스택의 맨 위에 있고, 장치 화면에서 볼 수 있는 포그라운드 테스크이며, 사용자와 현재 상호작용하고 있다. 이런 액티비티는 시스템 리소스가 부족할 때에도 거의 중단되지 않는다.

- **일시 중지(Paused)** - 사용자가 화면에서 볼 수 있지만 포커스를 갖고 있지 않는 경우다. 현재 실행 중인 다른 액티비티가 이 액티비티의 화면을 부분적으로 가리고 있기 때문이다.

- **중단(Stopped)** - 액티비티가 사용자에게 보이지 않는다. 장치 화면에서 이 액티비티 화면 전체를 다른 액티비티가 가리고 있을 때다. 일시 중지 액티비티처럼 이 액티비티는 모든 상태와 멤버 데이터를 보존하고 있다. 그러나 시스템 리소스가 부족할 때 중단될 가능성이 높다.

- **소멸(Killed)** - 메모리 해제를 위해 런타임 시스템에 의해 액티비티가 종료되었으며, 액티비티 스택에도 존재하지 않는다. 만일 애플리케이션에서 요청하면 이런 액티비티들은 다시 시작되어야 한다.

# 3-6. 구성 변경

지금까지 안드로이드 액티비티의 상태가 변하는 두 가지 요인을 알아보았다. 정리하면 포그라운드와 백그라운드 간의 액티비티 이동과 메모리 해제를 위해 런타임 시스템이 액티티비를 종료시키는 것이다. 그리고 한 가지가 더있다. 그것은 장이 구성의 변경이다.

기본적으로 화면에 나타난 액티비티의 모습(사용자 인터페이스)에 영향을 주는 구성 변경은 액티비티 인스턴스를 소멸시키고 새로 생성되게 만든다. 예를 들어, 장치의 방향을 가로에서 세로 또는 세로에서 가로로 회전시킬 때, 시스템 폰트 설정을 변경할 때 등이다.

액티비티가 새로 생성되는 이유는 다음과 같다. 구성 변경은 사용자 인터페이스의 레이아웃과 같은 리소스에 영향을 주므로 영향을 받은 액티비티 인스턴스를 소멸시키고 다시 생성하는 것이 그런 변경에 응답하는 가장 빠른 방법이기 때문이다.

# 3-7. 정리

* 안드로이드 5.0 롤리팝부터 안드로이드 애플리케이션은 안드로이드 런타임(ART) 시스템의 통제하에 리눅스 프로세스로 실행된다.

* 각 애플리케이션은 액티비티나 서비스의 형태로된 컴포넌트로 구성된다.

* 일반적으로 모바일 장치에서는 리소스가 제한된다. 특히, 메모리가 그렇다. 

* 그래서 안드로이드 런타임 시스템은 메모리가 부족할 때 프로세스(백그라운드 서비스의 형태의 프로세스와 각각의 액티비티 프로세스)를 중단시킬 수 있다.

* 중단시킬 프로세스를 결정할 때 런타임 시스템은 프로세스 상태를 감안하며, 프로세스 상태는 그 프로세스가 포함하여 실행하는 액티비티의 상태에 따라 좌우된다.

* 안드로이드 애플리케이션은 실행되는 동안 다양한 상태를 거치며, 그런 상태 변화는 안드로이드 런타임에 의해 제어된다.

* 기본적으로 안드로이드 애플리케이션에서는 시스템이 상태 변화를 알려줄 때 응답할 수 있어야 한다.
